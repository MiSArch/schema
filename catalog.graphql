schema @link(import : ["@key", "@shareable", "FieldSet"], url : "https://specs.apollo.dev/federation/v2.5"){
  query: Query
  mutation: Mutation
}

"Marks the field, argument, input field or enum value as deprecated"
directive @deprecated(
    "The reason for the deprecation"
    reason: String = "No longer supported"
  ) on FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE | INPUT_FIELD_DEFINITION

"Directs the executor to include this field or fragment only when the `if` argument is true"
directive @include(
    "Included when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Space separated list of primary keys needed to access federated object"
directive @key(fields: FieldSet!, resolvable: Boolean = true) repeatable on OBJECT | INTERFACE

"Links definitions within the document to external schemas."
directive @link(as: String, import: [link__Import], url: String!) repeatable on SCHEMA

"Indicates an Input Object is a OneOf Input Object."
directive @oneOf on INPUT_OBJECT

"Indicates that given object and/or field can be resolved by multiple subgraphs"
directive @shareable repeatable on OBJECT | FIELD_DEFINITION

"Directs the executor to skip this field or fragment when the `if` argument is true."
directive @skip(
    "Skipped when true."
    if: Boolean!
  ) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"Exposes a URL that specifies the behaviour of this scalar."
directive @specifiedBy(
    "The URL that specifies the behaviour of this scalar."
    url: String!
  ) on SCALAR

"A characteristic of a Category."
interface CategoryCharacteristic implements Node {
  "The Category this item belongs to."
  category: Category!
  "The description of the CategoryCharacteristic."
  description: String!
  "The ID of the node."
  id: UUID!
  "The name of the CategoryCharacteristic."
  name: String!
}

"A value for a CategoryCharacteristic."
interface CategoryCharacteristicValue {
  "The associated CategoryCharacteristic this is a value of."
  characteristic: CategoryCharacteristic!
}

"An object with an ID."
interface Node {
  "The ID of the node."
  id: UUID!
}

union _Entity = CategoricalCategoryCharacteristic | Category | NumericalCategoryCharacteristic | Product | ProductVariant | ProductVariantVersion

"A categorical characteristic of a category."
type CategoricalCategoryCharacteristic implements CategoryCharacteristic & Node @key(fields : "id", resolvable : true) {
  "The Category this item belongs to."
  category: Category!
  "The description of the CategoryCharacteristic."
  description: String!
  "The ID of the node."
  id: UUID!
  "The name of the CategoryCharacteristic."
  name: String!
}

"A possible value for a categorical characteristic."
type CategoricalCategoryCharacteristicValue implements CategoryCharacteristicValue @shareable {
  "The associated CategoryCharacteristic this is a value of."
  characteristic: CategoryCharacteristic!
  "The value of the characteristic."
  value: String!
}

"A category"
type Category implements Node @key(fields : "id", resolvable : true) {
  "Get characteristics for the category"
  characteristics(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: CategoryCharacteristicOrderInput,
    "Number of items to skip"
    skip: Int
  ): CategoryCharacteristicConnection!
  "The description of the category."
  description: String!
  "The ID of the node."
  id: UUID!
  "The name of the category."
  name: String!
  "Get all associated products"
  products(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: ProductOrderInput,
    "Number of items to skip"
    skip: Int
  ): ProductConnection!
}

"A connection to a list of `CategoryCharacteristic` values."
type CategoryCharacteristicConnection @shareable {
  "Whether this connection has a next page"
  hasNextPage: Boolean!
  "The resulting ."
  nodes: [CategoryCharacteristic!]!
  "The total amount of items in this connection"
  totalCount: Int!
}

"A connection to a list of `CategoryCharacteristicValue` values."
type CategoryCharacteristicValueConnection @shareable {
  "Whether this connection has a next page"
  hasNextPage: Boolean!
  "The resulting ."
  nodes: [CategoryCharacteristicValue!]!
  "The total amount of items in this connection"
  totalCount: Int!
}

"A connection to a list of `Category` values."
type CategoryConnection @shareable {
  "Whether this connection has a next page"
  hasNextPage: Boolean!
  "The resulting ."
  nodes: [Category!]!
  "The total amount of items in this connection"
  totalCount: Int!
}

type Mutation {
  "Create a new value for a characteristic whose values have no further meaning"
  createCategoricalCategoryCharacteristic(
    "Input for the createCategoricalCategoryCharacteristic mutation"
    input: CreateCategoricalCategoryCharacteristicInput!
  ): CategoricalCategoryCharacteristic!
  "Create a new category"
  createCategory(
    "Input for the createCategory mutation"
    input: CreateCategoryInput!
  ): Category!
  "Create a new numerical category characteristic"
  createNumericalCategoryCharacteristic(
    "Input for the createNumericalCategoryCharacteristic mutation"
    input: CreateNumericalCategoryCharacteristicInput!
  ): NumericalCategoryCharacteristic!
  "Create a new product"
  createProduct(
    "Input for the createProduct mutation"
    input: CreateProductInput!
  ): Product!
  "Create a new product variant"
  createProductVariant(
    "Input for the createProductVariant mutation"
    input: CreateProductVariantInput!
  ): ProductVariant!
  "Create a new product variant version"
  createProductVariantVersion(
    "Input for the createProductVariantVersion mutation"
    input: CreateProductVariantVersionInput!
  ): ProductVariantVersion!
}

"A numerical characteristic of a Category."
type NumericalCategoryCharacteristic implements CategoryCharacteristic & Node @key(fields : "id", resolvable : true) {
  "The Category this item belongs to."
  category: Category!
  "The description of the CategoryCharacteristic."
  description: String!
  "The ID of the node."
  id: UUID!
  "The name of the CategoryCharacteristic."
  name: String!
  "The unit of the NumericalCategoryCharacteristic."
  unit: String!
}

"A numerical value of a NumericalCategoryCharacteristic."
type NumericalCategoryCharacteristicValue implements CategoryCharacteristicValue @shareable {
  "The associated CategoryCharacteristic this is a value of."
  characteristic: CategoryCharacteristic!
  "The value of the NumericalCategoryCharacteristic."
  value: Float!
}

"A product."
type Product implements Node @key(fields : "id", resolvable : true) {
  "Get all associated Categories"
  categories(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: CategoryOrderInput,
    "Number of items to skip"
    skip: Int
  ): CategoryConnection!
  "The default variant of the product."
  defaultVariant: ProductVariant!
  "The ID of the node."
  id: UUID!
  "An internal name to identify the Product, not visible to customers."
  internalName: String!
  "If true, the Product is visible to customers."
  isPubliclyVisible: Boolean!
  "Get all associated ProductVariants"
  variants(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: ProductVariantOrderInput,
    "Number of items to skip"
    skip: Int
  ): ProductVariantConnection!
}

"A connection to a list of `Product` values."
type ProductConnection @shareable {
  "Whether this connection has a next page"
  hasNextPage: Boolean!
  "The resulting ."
  nodes: [Product!]!
  "The total amount of items in this connection"
  totalCount: Int!
}

"A variant of a Product."
type ProductVariant implements Node @key(fields : "id", resolvable : true) {
  "The current version of the ProductVariant."
  currentVersion: ProductVariantVersion!
  "The ID of the node."
  id: UUID!
  "If true, the ProductVariant is visible to customers."
  isPubliclyVisible: Boolean!
  "The Product belonging to this variant."
  product: Product!
  "Get all associated versions"
  versions(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: ProductVariantVersionOrderInput,
    "Number of items to skip"
    skip: Int
  ): ProductVariantVersionConnection!
}

"A connection to a list of `ProductVariant` values."
type ProductVariantConnection @shareable {
  "Whether this connection has a next page"
  hasNextPage: Boolean!
  "The resulting ."
  nodes: [ProductVariant!]!
  "The total amount of items in this connection"
  totalCount: Int!
}

"A version of a ProductVariant."
type ProductVariantVersion implements Node @key(fields : "id", resolvable : true) {
  "The amount of days for which an instance of the ProductVariantVersion can be returned after purchase"
  canBeReturnedForDays: Float
  "Get all associated CategoryCharacteristicValues"
  characteristicValues(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: CategoryCharacteristicValueOrderInput,
    "Number of items to skip"
    skip: Int
  ): CategoryCharacteristicValueConnection!
  "The date when the ProductVariantVersion version was created."
  createdAt: DateTime!
  "The description of the ProductVariantVersion."
  description: String!
  "The ID of the node."
  id: UUID!
  "The name of the ProductVariantVersion."
  name: String!
  "The ProductVariant this is a version of."
  productVariant: ProductVariant!
  "The retail price of the ProductVariantVersion."
  retailPrice: Int!
  "The version of the ProductVariantVersion."
  version: Int!
}

"A connection to a list of `ProductVariantVersion` values."
type ProductVariantVersionConnection @shareable {
  "Whether this connection has a next page"
  hasNextPage: Boolean!
  "The resulting ."
  nodes: [ProductVariantVersion!]!
  "The total amount of items in this connection"
  totalCount: Int!
}

type Query {
  "Union of all types that use the @key directive, including both types native to the schema and extended types"
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
  "Get all categories"
  categories(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: CategoryOrderInput,
    "Number of items to skip"
    skip: Int
  ): CategoryConnection!
  "Get a category by id"
  category(
    "The id of the category"
    id: UUID!
  ): Category!
  "Get a product by id"
  product(
    "The id of the product"
    id: UUID!
  ): Product!
  "Get all products"
  products(
    "Number of items to return"
    first: Int,
    "Ordering"
    orderBy: ProductOrderInput,
    "Number of items to skip"
    skip: Int
  ): ProductConnection!
}

type _Service {
  sdl: String!
}

"CategoryCharacteristic order fields"
enum CategoryCharacteristicOrderField {
  "Order categoryCharacteristics by their id"
  ID
}

"CategoryCharacteristicValue order fields"
enum CategoryCharacteristicValueOrderField {
  "Order categoryCharacteristicValues by their id"
  ID
}

"Category order fields"
enum CategoryOrderField {
  "Order categories by their id"
  ID
}

"Order direction"
enum OrderDirection {
  "Ascending order"
  ASC
  "Descending order"
  DESC
}

"Product order fields"
enum ProductOrderField {
  "Order products by their id"
  ID
}

"ProductVariant order fields"
enum ProductVariantOrderField {
  "Order productVariants by their id"
  ID
}

"ProductVariantVersion order fields"
enum ProductVariantVersionOrderField {
  "Order productVariantVersions by their id"
  ID
}

"A slightly refined version of RFC-3339 compliant DateTime Scalar"
scalar DateTime

"Federation type representing set of fields"
scalar FieldSet

"A universally unique identifier compliant UUID Scalar"
scalar UUID

"Federation scalar type used to represent any external entities passed to _entities query."
scalar _Any

scalar link__Import

"Input to create a CategoricalCategoryCharacteristic for a Category"
input CategoricalCategoryCharacteristicInput {
  "The description of the CategoricalCategoryCharacteristic"
  description: String!
  "The name of the CategoricalCategoryCharacteristic"
  name: String!
}

"Input for creating a CategoricalCategoryCharacteristicValue."
input CategoricalCategoryCharacteristicValueInput {
  "The id of the CategoryCharacteristic."
  characteristicId: UUID!
  "The value of the CategoricalCategoryCharacteristicValue."
  value: String!
}

"CategoryCharacteristic order"
input CategoryCharacteristicOrderInput {
  "The direction to order by"
  direction: OrderDirection!
  "The field to order by"
  field: CategoryCharacteristicOrderField!
}

"CategoryCharacteristicValue order"
input CategoryCharacteristicValueOrderInput {
  "The direction to order by"
  direction: OrderDirection!
  "The field to order by"
  field: CategoryCharacteristicValueOrderField!
}

"Category order"
input CategoryOrderInput {
  "The direction to order by"
  direction: OrderDirection!
  "The field to order by"
  field: CategoryOrderField!
}

"Input for the createCategoricalCategoryCharacteristic mutation"
input CreateCategoricalCategoryCharacteristicInput {
  "The Category that the CategoricalCategoryCharacteristicI belongs to"
  categoryId: UUID!
  "The description of the CategoricalCategoryCharacteristic"
  description: String!
  "The name of the CategoricalCategoryCharacteristic"
  name: String!
}

"Input for the createCategory mutation"
input CreateCategoryInput {
  "The CategoricalCategoryCharacteristics of the Category"
  categoricalCharacteristics: [CategoricalCategoryCharacteristicInput!]!
  "The description of the Category"
  description: String!
  "The name of the Category"
  name: String!
  "The NumericalCategoryCharacteristics of the Category"
  numericalCharacteristics: [NumericalCategoryCharacteristicInput!]!
}

"Input for the createNumericalCategoryCharacteristic mutation"
input CreateNumericalCategoryCharacteristicInput {
  "The Category that the NumericalCategoryCharacteristic belongs to"
  categoryId: UUID!
  "The description of the NumericalCategoryCharacteristic"
  description: String!
  "The name of the NumericalCategoryCharacteristic"
  name: String!
  "The unit of the NumericalCategoryCharacteristic"
  unit: String!
}

"Input for the createProduct mutation"
input CreateProductInput {
  "The Categories this product is associated with."
  categoryIds: [UUID!]!
  "The default ProductVariant of the Product."
  defaultVariant: ProductVariantInput!
  "An internal name to identify the Product, not visible to customers."
  internalName: String!
  "If true, the Product is visible to customers."
  isPubliclyVisible: Boolean!
}

"Input for the createProductVariant mutation"
input CreateProductVariantInput {
  "The initial ProductVariantVersion of the ProductVariant."
  initialVersion: ProductVariantVersionInput!
  "If true, the ProductVariant is visible to customers."
  isPubliclyVisible: Boolean!
  "The id of the Product this ProductVariant belongs to."
  productId: UUID!
}

"Input for the createProductVariantVersion mutation"
input CreateProductVariantVersionInput {
  "The amount of days for which an instance of the ProductVariant can be returned after purchase"
  canBeReturnedForDays: Float
  "The CategoricalCategoryCharacteristicValues of the ProductVariant, must be compatible with the Categories of the associated Product."
  categoricalCharacteristicValues: [CategoricalCategoryCharacteristicValueInput!]!
  "The description of the ProductVariant."
  description: String!
  "The name of the ProductVariant."
  name: String!
  "The NumericalCategoryCharacteristicValues of the ProductVariant, must be compatible with the Categories of the associated Product."
  numericalCharacteristicValues: [NumericalCategoryCharacteristicValueInput!]!
  "The id of the ProductVariant this ProductVariantVersion belongs to."
  productVariantId: UUID!
  "The retail price of the ProductVariant."
  retailPrice: Int!
}

"Input to create a characteristic whose values have arithmetic meaning, i.e. '8GB'"
input NumericalCategoryCharacteristicInput {
  "The description of the NumericalCategoryCharacteristic"
  description: String!
  "The name of the NumericalCategoryCharacteristic"
  name: String!
  "The unit of the NumericalCategoryCharacteristic"
  unit: String!
}

"Input for creating a NumericalCategoryCharacteristicValue."
input NumericalCategoryCharacteristicValueInput {
  "The id of the CategoryCharacteristic."
  characteristicId: UUID!
  "The value of the NumericalCategoryCharacteristicValue."
  value: Float!
}

"Product order"
input ProductOrderInput {
  "The direction to order by"
  direction: OrderDirection!
  "The field to order by"
  field: ProductOrderField!
}

"Input for creating a product variant"
input ProductVariantInput {
  "The initial ProductVariantVersion of the ProductVariant."
  initialVersion: ProductVariantVersionInput!
  "If true, the ProductVariant is visible to customers."
  isPubliclyVisible: Boolean!
}

"ProductVariant order"
input ProductVariantOrderInput {
  "The direction to order by"
  direction: OrderDirection!
  "The field to order by"
  field: ProductVariantOrderField!
}

"Input for creating a ProductVariantVersion."
input ProductVariantVersionInput {
  "The amount of days for which an instance of the ProductVariant can be returned after purchase"
  canBeReturnedForDays: Float
  "The CategoricalCategoryCharacteristicValues of the ProductVariant, must be compatible with the Categories of the associated Product."
  categoricalCharacteristicValues: [CategoricalCategoryCharacteristicValueInput!]!
  "The description of the ProductVariant."
  description: String!
  "The name of the ProductVariant."
  name: String!
  "The NumericalCategoryCharacteristicValues of the ProductVariant, must be compatible with the Categories of the associated Product."
  numericalCharacteristicValues: [NumericalCategoryCharacteristicValueInput!]!
  "The retail price of the ProductVariant."
  retailPrice: Int!
}

"ProductVariantVersion order"
input ProductVariantVersionOrderInput {
  "The direction to order by"
  direction: OrderDirection!
  "The field to order by"
  field: ProductVariantVersionOrderField!
}
